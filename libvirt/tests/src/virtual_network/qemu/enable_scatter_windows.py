# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#   Copyright Redhat
#
#   SPDX-License-Identifier: GPL-2.0
#   Author: Yiqian Wei<yiwei@redhat.com>
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import time
import os

from virttest import utils_misc, utils_net, utils_test
from virttest.utils_windows import virtio_win
from virttest import virsh
from virttest.libvirt_xml import vm_xml
from virttest import data_dir


def run(test, params, env):
    """
    Change certain netkvm driver parameter value and
    check the setting result.

    1) start vm
    2) check and install wireshark and winpcap
    3) enable netkvm driver TxLSO
    4) start File Transfer and use WinDump to log traffic and Wireshark
       for analysis, some packets should be over standard_frame_size in length.
    5) disable TxLSO and set MTU to 1000
    6) start file transfer and log file transfer traffic again,
       no packet length should over reduced_frame_size

    param test: the test object
    param params: the test params
    param env: test environment
    """

    def _is_process_finished(session, process_name):
        """
        Check whether the target process is finished running
        param session: a guest session to send command
        param process_name: the target process name

        return: True if process does not exists,
                False if still exists
        """
        check_proc_cmd = check_proc_temp % process_name
        status, output = session.cmd_status_output(check_proc_cmd)
        if status:
            return False
        return process_name not in output

    def _start_windump_session():
        """
        Start a WinDump session and log network traffic to a file
        """
        test.log.debug("Start WinDump session")
        session_serial = vm.wait_for_serial_login(timeout=timeout)
        guest_ip = vm.get_address()
        try:
            run_windump_cmd = run_windump_temp % (host_ip, guest_ip)
            status, output = session_serial.cmd_status_output(
                run_windump_cmd, timeout=timeout
            )
            if status:
                test.error(
                    "Failed to start WinDump session, status=%s, output=%s"
                    % (status, output)
                )
            is_started = utils_misc.wait_for(
                lambda: not _is_process_finished(
                    session_serial, params.get("windump_name")
                ),
                20,
                5,
                1,
            )
            if not is_started:
                test.error("Timeout when waiting for WinDump to start")
        finally:
            session_serial.close()

    def _stop_windump_session():
        """
        Stop the running WinDump session
        """
        test.log.debug("Stop WinDump")
        status, output = session.cmd_status_output(stop_windump_cmd, timeout=timeout)
        if status:
            test.error(
                "Failed to stop WinDump: status=%s, output=%s" % (status, output)
            )

    def _parse_log_file(packet_filter):
        """
        Parse the log file generated by the previous wireshark session.

        param packet_filter: the filter to apply when dump packets
        return: the output of the parse result
        """
        test.log.debug("Parse captured packets using Wireshark")
        parse_log_cmd = parse_log_temp % packet_filter
        status, output = session.cmd_status_output(parse_log_cmd, timeout=timeout)
        if status != 0:
            test.error(
                "Failed to parse session log file, status=%s, output=%s"
                % (status, output)
            )
        return output

    def _get_traffic_log(packet_filter):
        """
        Use WinDump to capture the file transfer network traffic,
        and return the packet analysis output.

        :param packet_filter: The filter to apply when analyzing packets
        :return: The output of the parse result
        """
        _start_windump_session()
        test.log.debug("Start file transfer")
        utils_test.run_file_transfer(test, params, env)
        time.sleep(30)
        _stop_windump_session()
        return _parse_log_file(packet_filter)

    def _set_driver_param(index):
        """
        set the netkvm driver param's value.

        param index: the index of the list of target params
        """
        param_name = param_names[index]
        param_value = param_values[index]
        utils_net.set_netkvm_param_value(vm, param_name, param_value)

    timeout = params.get_numeric("login_timeout", 360)
    driver_verifier = params["driver_verifier"]
    autoit_name = params.get("autoit_name")
    run_windump_temp = params.get("run_windump_temp")
    stop_windump_cmd = params.get("stop_windump_cmd")
    check_proc_temp = params.get("check_proc_temp")
    parse_log_temp = params.get("parse_log_temp")
    param_names = params.get_list("param_names")
    param_values = params.get_list("param_values")
    winutils_iso = params.get("cdrom_winutils", "isos/windows/winutils.iso")
    virtio_iso = params.get("cdrom_virtio", "isos/windows/virtio-win.iso")
    install_winpcap_cmd = params.get("install_winpcap_cmd")
    standard_frame_size = params.get_numeric("standard_ethernet_frame_size", 1514)
    reduced_frame_size = params.get_numeric("reduced_ethernet_frame_size", 1014)
    packet_filter_large = params.get("packet_filter_large", f"frame.len>{standard_frame_size}")
    packet_filter_small = params.get("packet_filter_small", f"frame.len>{reduced_frame_size}")
    packet_length_indicator = params.get("packet_length_indicator", "Len")

    vm_name = params.get("main_vm")
    vm = env.get_vm(vm_name)
    test.log.debug("vm xml:\n%s", vm_xml.VMXML.new_from_dumpxml(vm_name))
    vm.verify_alive()
    host_ip = utils_net.get_host_ip_address(params)

    test.log.info("TEST_STEP 1: Start VM and login to guest")
    session = vm.wait_for_login(timeout=timeout)

    test.log.info("TEST_STEP 2: Attach required CDROMs (winutils and virtio-win)")
    # Attach winutils CDROM
    winutils_path = os.path.join(data_dir.get_data_dir(), winutils_iso)
    if os.path.exists(winutils_path):
        test.log.debug("Attaching winutils CDROM: %s", winutils_path)
        virsh.attach_disk(vm.name, winutils_path, "sdc",
                          extra="--type cdrom --mode readonly",
                          debug=True, ignore_status=False)
        test.log.debug("Successfully attached winutils CDROM")

    # Attach virtio-win CDROM
    virtio_path = os.path.join(data_dir.get_data_dir(), virtio_iso)
    real_virtio_path = os.path.realpath(virtio_path)
    if os.path.exists(real_virtio_path):
        test.log.debug("Attaching virtio-win CDROM: %s", real_virtio_path)
        virsh.attach_disk(vm.name, real_virtio_path, "sdd",
                          extra="--type cdrom --mode readonly",
                          debug=True, ignore_status=False)
        test.log.debug("Successfully attached virtio-win CDROM")

    # make sure to enter desktop
    virsh.sendkey(vm_name, "KEY_LEFTMETA KEY_D", ignore_status=True)
    time.sleep(30)

    test.log.info("TEST_STEP 3: Check if the driver is installed and verified")
    session = utils_test.qemu.windrv_check_running_verifier(
        session, vm, test, driver_verifier, timeout
    )

    test.log.info("TEST_STEP 4: Install winpcap")
    install_winpcap_cmd = utils_misc.set_winutils_letter(session, install_winpcap_cmd)
    status, output = session.cmd_status_output(install_winpcap_cmd, timeout=timeout)
    if status:
        test.error("Failed to install pcap, status=%s, output=%s" % (status, output))

    test.log.debug("Wait for pcap installation to complete")
    utils_misc.wait_for(
        lambda: _is_process_finished(session, autoit_name), timeout, 20, 3
    )

    test.log.info("TEST_STEP 5: Install WinDump and Wireshark (tshark)")
    for process_name in ["windump", "tshark"]:
        check_cmd = params["check_%s_installed_cmd" % process_name]
        install_cmd = utils_misc.set_winutils_letter(
            session, params["%s_install_cmd" % process_name]
        )

        is_installed = process_name in session.cmd_output(check_cmd)

        if not is_installed:
            test.log.debug("Installing %s", process_name)
            status, output = session.cmd_status_output(install_cmd, timeout=timeout)
            if status != 0:
                test.error(
                    "Failed to install %s, status=%s, output=%s"
                    % (process_name, status, output)
                )

            test.log.debug("Wait for %s installation to complete", process_name)
            utils_misc.wait_for(
                lambda pname=process_name: _is_process_finished(session, pname),
                timeout,
                20,
                3,
            )
            check_result = session.cmd_output(check_cmd).lower()
            if process_name not in check_result:
                test.error("%s installation failed to verify." % process_name)
            test.log.debug("%s installed successfully.", process_name)
        else:
            test.log.debug("%s is already installed", process_name)

    session.close()

    virtio_win.prepare_netkvmco(vm)
    test.log.info("TEST_STEP 6: Enable scatter gather")
    _set_driver_param(0)

    session = vm.wait_for_login(timeout=timeout)
    test.log.info("TEST_STEP 7: Log network traffic with scatter gather enabled")
    output = _get_traffic_log(packet_filter_large)
    test.log.debug(f"Check length > {standard_frame_size} packets")
    if packet_length_indicator not in output:
        test.fail(f"No packet length >= {standard_frame_size}, output=%s" % output)
    session.close()

    test.log.info("TEST_STEP 8: Disable scatter gather")
    _set_driver_param(1)
    _set_driver_param(2)

    session = vm.wait_for_login(timeout=timeout)
    test.log.info("TEST_STEP 9: Log network traffic with scatter gather disabled")
    test.log.debug(f"Check length > {reduced_frame_size} packets")
    output = _get_traffic_log(packet_filter_small)
    if packet_length_indicator in output:
        test.fail(f"Some packet length > {reduced_frame_size}, output=%s" % output)
    session.close()
