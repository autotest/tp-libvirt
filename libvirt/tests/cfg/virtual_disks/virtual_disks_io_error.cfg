- virtual_disks.io_error:
    type = virtual_disks_io_error
    start_vm = "no"
    virt_disk_device = "disk"
    take_regular_screendumps=no
    func_supported_since_libvirt_ver = (10, 10, 0)
    variants:
        - hypervisor_message:
            device_manager_path = "/tmp/img"
            prepare_file = "dd if=/dev/zero of=${device_manager_path} count=512 bs=1048576"
            device_manager = "errdev1"
            disk_dict = {"type_name": "block",'source': {'attrs': {'dev': '/dev/mapper/${device_manager}'}}, "target": {"dev": "vdb", "bus": "virtio"}, "driver": {"name": "qemu", "type": "raw"}}
            dd_in_guest = "dd if=/dev/vdb of=/tmp/img bs=1024 count=524288"
            dd_msg = "Input/output error"
            event_msg = "/dev/mapper/${device_manager}.*report due to message"
            guest_log_msg = "IO error device=.*Input/output error"
            dominfo_msg = "I/O error:.*path='/dev/mapper/${device_manager}'.*message='Input/output error'"
        - enospc:
            enospc_test = "yes"
            target_disk = "vdb"
            partition_path = "/tmp/small.disk"
            mount_point = "/mnt/enospc_test"
            disk_path = "${mount_point}/disk.img"
            prepare_file = "truncate -s 11M ${partition_path}; mkfs.ext3 -F ${partition_path}; mkdir -p ${mount_point}; mount ${partition_path} ${mount_point}; qemu-img create -f qcow2 ${disk_path} 20M"
            disk_dict = '{"type_name": "file", "source": {"attrs": {"file": "${disk_path}"}}, "target": {"dev": "vdb", "bus": "virtio"}, "driver": {"name": "qemu", "type": "qcow2"}}'
            dd_msg = "No space left on device"
            event_msg = "${disk_path}.*pause due to enospc"
            guest_log_msg = "IO error.*No space left on device"
            dominfo_msg = "I/O error:.*path='${disk_path}'.*message='No space left on device'"
            cleanup_cmd = "umount ${mount_point} || true; rm -rf ${mount_point}; rm -f ${partition_path}"
            variants:
                - default:
                - with_snapshot:
                    with_snapshot = "yes"
                    snapshot_name = "sn1"
